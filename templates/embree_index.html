<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <!-- Include the CesiumJS JavaScript and CSS files -->
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.115/Build/Cesium/Cesium.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.115/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.7.5/proj4.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css">
</head>
<style>
  canvas { display: block; }
  #cesiumContainer {
    width: 100%;
    height: 100vh;
    position: relative; /* 确保父容器是定位元素 */
  }
  #goToLocation {
    position: absolute; /* 绝对定位使其能够悬浮 */
    right: 20px; /* 距离容器右边界20px */
    bottom: 20px; /* 距离容器底部20px */
    z-index: 100; /* 确保按钮在Cesium视图上方 */
    padding: 10px 20px; /* 增加一些内边距使按钮看起来更好 */
    background-color: #007bff; /* 蓝色背景 */
    color: white; /* 文字颜色为白色 */
    border: none; /* 无边框 */
    border-radius: 5px; /* 圆角边框 */
    cursor: pointer; /* 鼠标悬停时显示指针 */
  }
  #goToLocation:hover {
    background-color: #0056b3; /* 鼠标悬停时的背景色 */
  }
</style>

<body>

<div id="cesiumContainer"></div>
<!--<input type="range" id="timeSlider" min="0" max="144" value="72">-->
<button id="goToLocation">Go to Location</button>
<button id="calculate">calculate</button>
<div class="container">
  <div class="time-display">
    <span id="time-display">16:48</span>
    <input type="date" id="date-picker" value="2024-05-14">
    <button id="reset-button" onclick="resetTime()">⟳</button>
  </div>
  <div class="slider-container">
    <span>Sunrise</span>
    <input type="range" id="time-slider" min="0" max="144" value="98" oninput="updateTime()">
    <span>Sunset</span>
  </div>
  <br>
  <div class="slider-container-second">
    <span>Shade</span>
    <input type="range" id="time-slider-second" min="0" max="144" value="98" oninput="updateTime()">
    <span>Shortest</span>
  </div>
</div>
<script type="module">
  // Your access token can be found at: https://ion.cesium.com/tokens.
  // This is the default access token from your ion account
  var click_point=[]
  var longitude = 11.573213852350015;
  var latitude =  48.13659884837134;
  var height = 900.0; // 目标观察高度，单位为米
  var circles=[];
  var object_list=[]
  // 定义按钮点击事件处理函数
  document.getElementById('goToLocation').addEventListener('click', function() {
    let fly_list=[]
// 创建Cesium Viewer实例
    const geojson = {
      "type": "FeatureCollection", "features": [{"type": "Feature", "geometry": {"type": "MultiLineString", "coordinates": [[[11.577608, 48.141452], [11.577498, 48.141475], [11.577387, 48.141497], [11.577289, 48.141517], [11.577244, 48.141526], [11.577108, 48.141553], [11.576997, 48.141576], [11.576923, 48.141591]]]}, "properties": {"id": 218, "seq": 8, "shade": 0.6}}, {"type": "Feature", "geometry": {"type": "MultiLineString", "coordinates": [[[11.580447, 48.142648], [11.580475, 48.142639], [11.580497, 48.142624], [11.580511, 48.142606], [11.580516, 48.142585], [11.58051, 48.142565]]]}, "properties": {"id": 247, "seq": 29, "shade": 1.0}}, {"type": "Feature", "geometry": {"type": "MultiLineString", "coordinates": [[[11.577414, 48.140425], [11.577403, 48.14049]]]}, "properties": {"id": 343, "seq": 2, "shade": 1.0}}, {"type": "Feature", "geometry": {"type": "MultiLineString", "coordinates": [[[11.57809, 48.140288], [11.577996, 48.140323], [11.577742, 48.140378], [11.577499, 48.140416], [11.577414, 48.140425]]]}, "properties": {"id": 344, "seq": 1, "shade": 1.0}}, {"type": "Feature", "geometry": {"type": "MultiLineString", "coordinates": [[[11.580327, 48.142384], [11.579794, 48.142497]]]}, "properties": {"id": 363, "seq": 26, "shade": 0.6}}, {"type": "Feature", "geometry": {"type": "MultiLineString", "coordinates": [[[11.580815, 48.142506], [11.580718, 48.1423], [11.580327, 48.142384]]]}, "properties": {"id": 366, "seq": 27, "shade": 0.8}}, {"type": "Feature", "geometry": {"type": "MultiLineString", "coordinates": [[[11.579794, 48.142497], [11.579737, 48.142379]]]}, "properties": {"id": 369, "seq": 25, "shade": 1.0}}, {"type": "Feature", "geometry": {"type": "MultiLineString", "coordinates": [[[11.578207, 48.142571], [11.578562, 48.142499]]]}, "properties": {"id": 397, "seq": 21, "shade": 1.0}}, {"type": "Feature", "geometry": {"type": "MultiLineString", "coordinates": [[[11.578207, 48.142571], [11.578265, 48.142693]]]}, "properties": {"id": 398, "seq": 20, "shade": 1.0}}, {"type": "Feature", "geometry": {"type": "MultiLineString", "coordinates": [[[11.578265, 48.142693], [11.578313, 48.142795]]]}, "properties": {"id": 402, "seq": 19, "shade": 0.0}}, {"type": "Feature", "geometry": {"type": "MultiLineString", "coordinates": [[[11.578562, 48.142499], [11.57915, 48.142378]]]}, "properties": {"id": 403, "seq": 22, "shade": 0.4}}, {"type": "Feature", "geometry": {"type": "MultiLineString", "coordinates": [[[11.579205, 48.142492], [11.579737, 48.142379]]]}, "properties": {"id": 408, "seq": 24, "shade": 0.4}}, {"type": "Feature", "geometry": {"type": "MultiLineString", "coordinates": [[[11.579205, 48.142492], [11.57915, 48.142378]]]}, "properties": {"id": 409, "seq": 23, "shade": 1.0}}, {"type": "Feature", "geometry": {"type": "MultiLineString", "coordinates": [[[11.577445, 48.140797], [11.577403, 48.14049]]]}, "properties": {"id": 558, "seq": 3, "shade": 0.33333333333333337}}, {"type": "Feature", "geometry": {"type": "MultiLineString", "coordinates": [[[11.577445, 48.140797], [11.577457, 48.140881]]]}, "properties": {"id": 559, "seq": 4, "shade": 0.0}}, {"type": "Feature", "geometry": {"type": "MultiLineString", "coordinates": [[[11.576923, 48.141591], [11.576815, 48.141403]]]}, "properties": {"id": 571, "seq": 7, "shade": 1.0}}, {"type": "Feature", "geometry": {"type": "MultiLineString", "coordinates": [[[11.577692, 48.141844], [11.577657, 48.141673], [11.577608, 48.141452]]]}, "properties": {"id": 572, "seq": 9, "shade": 0.6666666666666667}}, {"type": "Feature", "geometry": {"type": "MultiLineString", "coordinates": [[[11.57756, 48.141259], [11.577497, 48.141032], [11.577457, 48.140881]]]}, "properties": {"id": 573, "seq": 5, "shade": 0.6666666666666667}}, {"type": "Feature", "geometry": {"type": "MultiLineString", "coordinates": [[[11.580815, 48.142506], [11.58051, 48.142565]]]}, "properties": {"id": 1008, "seq": 28, "shade": 0.6666666666666667}}, {"type": "Feature", "geometry": {"type": "MultiLineString", "coordinates": [[[11.580447, 48.142648], [11.580533, 48.142833]]]}, "properties": {"id": 1012, "seq": 30, "shade": 1.0}}, {"type": "Feature", "geometry": {"type": "MultiLineString", "coordinates": [[[11.580533, 48.142833], [11.580149, 48.142913]]]}, "properties": {"id": 1013, "seq": 31, "shade": 0.33333333333333337}}, {"type": "Feature", "geometry": {"type": "MultiLineString", "coordinates": [[[11.580151, 48.142973], [11.580157, 48.142943], [11.580149, 48.142913]]]}, "properties": {"id": 1016, "seq": 32, "shade": 1.0}}, {"type": "Feature", "geometry": {"type": "MultiLineString", "coordinates": [[[11.577938, 48.142874], [11.577924, 48.142783], [11.577919, 48.142703]]]}, "properties": {"id": 1220, "seq": 17, "shade": 0.5}}, {"type": "Feature", "geometry": {"type": "MultiLineString", "coordinates": [[[11.577839, 48.142536], [11.577886, 48.142585], [11.577919, 48.142703]]]}, "properties": {"id": 1221, "seq": 16, "shade": 0.0}}, {"type": "Feature", "geometry": {"type": "MultiLineString", "coordinates": [[[11.577318, 48.142386], [11.577288, 48.142321]]]}, "properties": {"id": 1328, "seq": 12, "shade": 1.0}}, {"type": "Feature", "geometry": {"type": "MultiLineString", "coordinates": [[[11.577414, 48.142586], [11.577371, 48.14249], [11.577318, 48.142386]]]}, "properties": {"id": 1330, "seq": 13, "shade": 1.0}}, {"type": "Feature", "geometry": {"type": "MultiLineString", "coordinates": [[[11.577692, 48.141844], [11.577114, 48.141947]]]}, "properties": {"id": 1364, "seq": 10, "shade": 0.8}}, {"type": "Feature", "geometry": {"type": "MultiLineString", "coordinates": [[[11.577114, 48.141947], [11.577288, 48.142321]]]}, "properties": {"id": 1365, "seq": 11, "shade": 1.0}}, {"type": "Feature", "geometry": {"type": "MultiLineString", "coordinates": [[[11.57756, 48.141259], [11.577467, 48.141288], [11.577371, 48.141302], [11.576897, 48.141388], [11.576815, 48.141403]]]}, "properties": {"id": 1433, "seq": 6, "shade": 0.5}}, {"type": "Feature", "geometry": {"type": "MultiLineString", "coordinates": [[[11.577938, 48.142874], [11.57817, 48.142825], [11.578273, 48.142803], [11.578313, 48.142795]]]}, "properties": {"id": 1668, "seq": 18, "shade": 0.6666666666666667}}, {"type": "Feature", "geometry": {"type": "MultiLineString", "coordinates": [[[11.577824, 48.142511], [11.577727, 48.142515], [11.577413, 48.142586]]]}, "properties": {"id": 2025, "seq": 14, "shade": 0.5}}, {"type": "Feature", "geometry": {"type": "MultiLineString", "coordinates": [[[11.577824, 48.142511], [11.577839, 48.142536]]]}, "properties": {"id": 2057, "seq": 15, "shade": 1.0}}]}

    const features = geojson.features;

    const promises = features.map(feature => {
      const coordinates = feature.geometry.coordinates[0];
      const positions = coordinates.map(coord => Cesium.Cartographic.fromDegrees(coord[0], coord[1]));

      return Cesium.sampleTerrain(viewer.terrainProvider, 13, positions)
              .then(updatedPositions => {
                const shade = feature.properties.shade;
                const color = getColorFromShade(shade)

                return viewer.entities.add({
                  polyline: {
                    positions: Cesium.Cartesian3.fromDegreesArrayHeights(
                            updatedPositions.flatMap(pos =>
                                    [Cesium.Math.toDegrees(pos.longitude), Cesium.Math.toDegrees(pos.latitude), pos.height]
                            ),


                    ),
                    width: 15,
                    material: color
                  }
                });
              });
    });

    Promise.all(promises).then(() => {
      viewer.zoomTo(viewer.entities);
      const property = new Cesium.SampledPositionProperty();
      fly_list.forEach((coord, index) => {
        const time = Cesium.JulianDate.addSeconds(Cesium.JulianDate.now(), index * 5, new Cesium.JulianDate());
        const position = Cesium.Cartesian3.fromRadians(coord[0], coord[1], coord[2]);
        property.addSample(time, position);
      });

      // 创建路径实体
      viewer.entities.add({
        availability: new Cesium.TimeIntervalCollection([new Cesium.TimeInterval({
          start: Cesium.JulianDate.now(),
          stop: Cesium.JulianDate.addSeconds(Cesium.JulianDate.now(), coordinates.length * 5, new Cesium.JulianDate())
        })]),
        position: property,
        point: { pixelSize: 10, color: Cesium.Color.RED },
        path: {
          resolution: 1,
          material: new Cesium.PolylineGlowMaterialProperty({
            glowPower: 0.1,
            color: Cesium.Color.YELLOW
          }),
          width: 10
        }
      });

      // 设置相机路径
      viewer.clock.startTime = Cesium.JulianDate.now();
      viewer.clock.stopTime = Cesium.JulianDate.addSeconds(Cesium.JulianDate.now(), coordinates.length * 5, new Cesium.JulianDate());
      viewer.clock.currentTime = viewer.clock.startTime;
      viewer.clock.clockRange = Cesium.ClockRange.CLAMPED;
      viewer.clock.clockStep = Cesium.ClockStep.SYSTEM_CLOCK;
      viewer.clock.multiplier = 1;

      viewer.trackedEntity = viewer.entities.values[0];
    });

  })
    // 加载GeoJSON数据并显示
    // viewer.dataSources.add(Cesium.GeoJsonDataSource.load(geojson));


  window.onload = function() {
    const now = new Date();
    const dateInput = document.getElementById('date-picker');
    const timeSlider = document.getElementById('time-slider');
    const timeDisplay = document.getElementById('time-display');
    const resetButton = document.getElementById("reset-button");

    dateInput.value = now.toISOString().split('T')[0];
    updateTimeSlider(now);

    dateInput.addEventListener('change', updateCesiumClock);
    timeSlider.oninput = function() {
      updateCesiumClock();
    };

    function updateTimeSlider(currentDateTime) {
      const currentMinutes = currentDateTime.getHours() * 60 + currentDateTime.getMinutes();
      timeSlider.value = Math.floor(currentMinutes / 10);
      updateCesiumClock();
    }
    const updateTime = () => {
      let minutes = timeSlider.value * 10;
      let hours = Math.floor(minutes / 60);
      minutes = minutes % 60;
      timeDisplay.textContent = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
    };

    const resetTime = () => {
      const now = new Date();
      dateInput.value = now.toISOString().split('T')[0];
      const hours = now.getHours();
      const minutes = now.getMinutes();
      const totalMinutes = hours * 60 + minutes;
      timeSlider.value = Math.round(totalMinutes / 10);
      updateTime();
      updateCesiumClock();
    };

    function updateCesiumClock() {
      const selectedDate = new Date(dateInput.value);
      const sliderValue = parseInt(timeSlider.value);
      const hours = Math.floor(sliderValue * 10 / 60);
      const minutes = (sliderValue * 10) % 60;
      selectedDate.setHours(hours, minutes, 0);

      viewer.clock.currentTime = Cesium.JulianDate.fromDate(selectedDate);
      viewer.clock.shouldAnimate = true;

      timeDisplay.textContent = `${hours}:${minutes}`;
    }
    resetButton.addEventListener("click", resetTime);
  };
  document.getElementById('calculate').addEventListener('click', function() {



    main(click_point)

  });
  async function point_cartesian(each_point_ori) {
    async function convertToCartesianWithTerrain(terrainProvider, position, ellipsoid) {
      // 使用 Cesium.sampleTerrain 获取地面高度的经纬度位置
      const updatedPositions = await Cesium.sampleTerrain(terrainProvider, 13, [position]);

      // 将更新后的经纬度位置转换为笛卡尔坐标
      const cartesianPosition = ellipsoid.cartographicToCartesian(updatedPositions[0]);

      return cartesianPosition;
    }

    // 调用示例
    const terrainProvider = viewer.terrainProvider;
    const position = Cesium.Cartographic.fromDegrees(each_point_ori[0], each_point_ori[1]);
    const ellipsoid = Cesium.Ellipsoid.WGS84;

    const cartesianPosition = await convertToCartesianWithTerrain(terrainProvider, position, ellipsoid);
    console.log(cartesianPosition);

    return getSunDirection(cartesianPosition);
  }
  async function main(click_point) {
    const date = document.getElementById('date-picker').value;
    const timeSlider = document.getElementById('time-slider');
    const hours = Math.floor(timeSlider.value * 10 / 60);
    const minutes = (timeSlider.value * 10) % 60;
    const time_str=`${hours}:${minutes}`
    const sample_point=[11.5745611, 48.1443432]
    let sun_vec=await point_cartesian(sample_point)
    // console.log(sun_vec,'sun_vec');
    console.log(`选定时间: ${hours}:${minutes}`);

    fetch_data({'date':date,'time':time_str,'sun_vec':sun_vec,'click_points':click_point})

  }

  function interpolateColor(color1, color2, factor) {
    if (arguments.length < 3) {
      factor = 0.5;
    }
    const result = color1.slice();
    for (let i = 0; i < 3; i++) {
      result[i] = Math.round(result[i] + factor * (color2[i] - result[i]));
    }
    return result;
  }

  const startColor = [253, 222, 85];  // FDDE55 in RGB
  const endColor = [3, 174, 210];     // 03AED2 in RGB

  // shade is a value between 0 and 1
  function getColorFromShade(shade) {
    const color = interpolateColor(startColor, endColor, shade);
    return Cesium.Color.fromBytes(color[0], color[1], color[2]);
  }

  function fetch_data(result){
    console.log(result,'result')
    fetch('/get-time', {
      method: 'POST', // 设置请求方法为 POST
      headers: {
        'Content-Type': 'application/json' // 设置请求头，指明发送的数据类型为 JSON
      },
      body: JSON.stringify({ key: result}) // 将要发送的数据转换成 JSON 字符串
    })
            .then(response => response.json()) // 解析返回的 JSON 数据
            .then(data => {
              const features = data['lines'].features;

              const promises = features.map(feature => {
                const coordinates = feature.geometry.coordinates[0];
                const positions = coordinates.map(coord => Cesium.Cartographic.fromDegrees(coord[0], coord[1]));

                return Cesium.sampleTerrain(viewer.terrainProvider, 13, positions)
                        .then(updatedPositions => {
                          const shade = feature.properties.shade;
                          const color = getColorFromShade(shade)
                          return viewer.entities.add({
                            polyline: {
                              positions: Cesium.Cartesian3.fromDegreesArrayHeights(
                                      updatedPositions.flatMap(pos => [Cesium.Math.toDegrees(pos.longitude), Cesium.Math.toDegrees(pos.latitude), pos.height])
                              ),
                              width: 5,
                              material: color
                            }
                          });
                        });
              });

              Promise.all(promises).then(() => {
                viewer.zoomTo(viewer.entities);
              });
            })
            .catch(error => console.error('Error:', error)); // 捕捉并处理任何在请求过程中出现的错误


  }
  Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI5ZjBmNDMzNC1iYWE1LTQ3MzktYTQ5MC1lZmFjNjk3NTYzN2QiLCJpZCI6MTk0ODIzLCJpYXQiOjE3MDc0NzE0NzJ9.LhKp3KFaLreNR5Ktq9JVUm_JA8a4bhQFe2qCr080Vmk';

  // Initialize the Cesium Viewer in the HTML element with the `cesiumContainer` ID.
  const viewer = new Cesium.Viewer('cesiumContainer', {
    terrain: Cesium.Terrain.fromWorldTerrain(),
    animation:false,//隐藏掉时钟 图中6

    timeline:false,//隐藏时间轴 图中7

    fullscreenButton:false,//隐藏全屏按钮 图中8

    geocoder:false,//隐藏搜索按钮 图中1

    homeButton:false,//隐藏home按钮 图中2

    navigationHelpButton:false,//隐藏帮助按钮 图中5

    sceneModePicker:false,//隐藏切换二三维按钮 图中3

    baseLayerPicker:false,//隐藏切换底图按钮 图中4

    creditContainer:document.createElement("div"),//隐藏logo  图中9

  });
  // 创建一个用于监听屏幕空间事件的处理器
  // viewer.clock.shouldAnimate = false;




  var handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
  function calculateDirectionVector(point1, point2) {
    // 计算从点1到点2的向量
    var directionVector = Cesium.Cartesian3.subtract(point2, point1, new Cesium.Cartesian3());

    // 将向量规范化为单位向量
    var unitDirectionVector = Cesium.Cartesian3.normalize(directionVector, new Cesium.Cartesian3());

    return unitDirectionVector;
  }
  function getSunDirection(cartesian) {

    var date = viewer.clock.currentTime

    var sunPosition = new Cesium.Cartesian3();
    Cesium.Simon1994PlanetaryPositions.computeSunPositionInEarthInertialFrame(date,sunPosition);
    // var sunPositionCartesian = Cesium.Cartesian3.fromArray(sunPosition);
    var temeToPseudoFixedMatrix = Cesium.Transforms.computeTemeToPseudoFixedMatrix(date);

// 使用转换矩阵将太阳位置从TEME转换到ECEF
    var sunPositionECEF = Cesium.Matrix3.multiplyByVector(temeToPseudoFixedMatrix, sunPosition, new Cesium.Cartesian3());

    var sunDirection= calculateDirectionVector(cartesian,sunPositionECEF)

    return sunDirection;
  }

  // 监听鼠标左键点击事件
  // handler.setInputAction(function(click) {
  //   var pickedObject = viewer.scene.pick(click.position);
  //   // 确保点击到了对象
  //   if (Cesium.defined(pickedObject)) {
  //     var cartesian = viewer.scene.pickPosition(click.position);
  //     // 确保获取到了有效的坐标
  //     if (Cesium.defined(cartesian)) {
  //       var cartographic = Cesium.Cartographic.fromCartesian(cartesian);
  //       var longitude = Cesium.Math.toDegrees(cartographic.longitude);
  //       var latitude = Cesium.Math.toDegrees(cartographic.latitude);
  //       var height = cartographic.height;
  //       console.log('Longitude: ' + longitude + ', Latitude: ' + latitude + ', Height: ' + height);
  //     }
  //
  //   }
  // }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
  async function isSunBlockedByModel(viewer, pointPosition, direction) {
    // 确保点位置和方向是Cesium.Cartesian3实例

    // 规范化方向向量
    Cesium.Cartesian3.normalize(direction, direction);

    // 创建射线
    var ray = new Cesium.Ray(pointPosition, direction);

    // 使用射线检测是否与场景中的3D模型相交
    var result = viewer.scene.pickFromRay(ray);

    // 如果result不是undefined，说明射线与某个模型相交
    if (result && result.position) {
      // 计算从射线起点到相交点的距离
      // var distance = Cesium.Cartesian3.distance(pointPosition, result.position);
      // var feature = result.object;
      // console.log(feature)

      // 尝试从特征的属性中获取建筑物的高度
      // var buildingHeight = feature.getProperty('height');
      // console.log(buildingHeight,'buildingHeight')
      // console.log(distance,'distance')
      return true;
    }

    // 如果没有相交，或者result中没有位置信息，返回undefined
    return false;
  }

  let globalPageX = 0;
  let globalPageY = 0;
function show_lines(){
  fetch('/geojson')
          .then(response => response.json())
          .then(data => {
            // 加载 GeoJSON 数据到 Cesium
            const geoJsonDataSource = new Cesium.GeoJsonDataSource.load(data, {
              stroke: Cesium.Color.RED, // 线条颜色
              strokeWidth: 3, // 线条宽度
              markerColor: Cesium.Color.YELLOW // 结点颜色
            });

            geoJsonDataSource.then(dataSource => {
              viewer.dataSources.add(dataSource);

              // 调整视角使其包含所有的GeoJSON数据
              viewer.zoomTo(dataSource);
            });
          })
          .catch(error => {
            console.error('Error loading GeoJSON: ', error);
          });

}
  // 全局监听鼠标移动事件来更新pageX和pageY
  document.addEventListener('click', function(event) {
    globalPageX = event.pageX;
    globalPageY = event.pageY;
    const oldContainer = document.getElementById('canvasContainer');
    if (oldContainer) {
      document.body.removeChild(oldContainer);
    }
  });
  function add_vector(startPoint,direction,color_str){
    var scaledDirectionVector = Cesium.Cartesian3.multiplyByScalar(direction, 20, new Cesium.Cartesian3());

// 计算终点坐标
    var endPoint = Cesium.Cartesian3.add(startPoint, scaledDirectionVector, new Cesium.Cartesian3());

// 使用Polyline添加一条线来表示向量
    viewer.entities.add({
      polyline: {
        positions: [startPoint, endPoint],
        width: 2,
        material: color_str, // 可以根据需要调整线的颜色
        // material: Cesium.Color.color_str, // 可以根据需要调整线的颜色
        arcType: Cesium.ArcType.NONE // 确保线段直接连接起点和终点
      }
    });
    // 使用射线检测是否与场景中的3D模型相交

  }
  async function add_round(startPoint,value){
    console.log('round')

    var color = Cesium.Color.fromBytes(255 * value, 0, 255 * (1 - value));

// 创建一个圆形实体
    var circle = viewer.entities.add({
      position: startPoint,
      ellipse: {
        semiMinorAxis: 2, // 半径20米
        semiMajorAxis:2, // 半径20米
        material: color // 使用计算得到的颜色
      }
    });
    circles.push(circle)
  }
  async function caculate_point_list(point_list,intensity_list,mode){

    circles.forEach(circle => {
      if (circle && viewer.entities.contains(circle)) {
        viewer.entities.remove(circle);
      } else {
        // console.log("Circle not found or already removed");
      }
    });




    var ellipsoid = viewer.scene.globe.ellipsoid;
    var positions = point_list.map(each_point_ori =>
            Cesium.Cartographic.fromDegrees(each_point_ori[0], each_point_ori[1])
    );

    await Cesium.sampleTerrain(viewer.terrainProvider, 13, positions).then(function(updatedPositions) {
      updatedPositions.forEach((updatedPos, index) => {
        var cartesian3 = ellipsoid.cartographicToCartesian(updatedPos);
        // var each_point = {'position': viewer.scene.cartesianToCanvasCoordinates(cartesian3)};
        add_round(cartesian3,intensity_list[index])
        // calculate_normal(each_point, cartesian3, mode)
        // reflect_list.push(reflect);
      });

      // console.log(reflect_list.length);2

    });
  }
  function calculateLightIntensity(distance, I0) {
    const result=(I0/2) * ( (distance) ** 2);
    // console.log(I0,result)
    return result;

  }

  async function calculate_normal(movement,cartesian_3,mode){
    let lightIntensity
    if (cartesian_3===''){
      var cartesian = viewer.scene.pickPosition(movement.position);
    }else {
      var cartesian = cartesian_3

    }

    //
    // console.log(cartesian,'cartesian')
    if (Cesium.defined(cartesian)) {



      // 如果没有相交，或者result中没有位置信息，返回undefined
      lightIntensity=1
// 计算光照强度


      // console.log(cartesian,sunDirection)
      // object_list.push(convertCartesianToEPSG25832(cartesian),Object.values(sunDirection))
      // add_vector(cartesian,sunDirection,Cesium..Color.RED)
      // console.log(cartesian)
      if (mode=="show"){
        add_round(cartesian,lightIntensity)
      }

      // console.log('finished')

      // console.log("Light Intensity:", lightIntensity);
      return lightIntensity



    }
  }

  handler.setInputAction(function(movement) {
    var cartesian = viewer.scene.pickPosition(movement.position);
    add_round(cartesian,1)

    // 检查是否有效
    if (Cesium.defined(cartesian)) {
      // 将 Cartesian3 坐标转换为地理坐标（经纬度）
      var cartographic = Cesium.Cartographic.fromCartesian(cartesian);

      // 获取经度和纬度（单位为弧度），将其转换为度
      var longitude = Cesium.Math.toDegrees(cartographic.longitude);
      var latitude = Cesium.Math.toDegrees(cartographic.latitude);
      click_point.push(longitude,latitude)
      if (click_point.length===2){
        main(click_point)
        click_point=[]
        const oldContainer = document.getElementById('canvasContainer');
        if (oldContainer) {
          document.body.removeChild(oldContainer);
        }
      }

      // 调用 draw_diagram 函数，并传递经纬度信息
      draw_diagram(movement, '', 'show');
    }


  }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

  viewer.scene.globe.enableLighting = true
  viewer.shadows = true
  viewer.terrainShadows = Cesium.ShadowMode.RECEIVE_ONLY
  //viewer.shadowMap.softShadows  = true
  viewer.shadowMap.darkness = 0.2 //阴影透明度--越大越透明
  let time = 0
  // const buildingTileset = await Cesium.createOsmBuildingsAsync();
  var tileset1 = await Cesium.Cesium3DTileset.fromIonAssetId(2492727);
  viewer.scene.primitives.add(tileset1);

  // 添加第二个 tileset
  var imageryProvider2 = await Cesium.IonImageryProvider.fromAssetId(4);
  viewer.imageryLayers.addImageryProvider(imageryProvider2);
  let baseTime = new Date();
  function createTimeSeries(list) {
    const totalMinutes = 24 * 60; // 一天总共有1440分钟
    const interval = totalMinutes / list.length; // 根据列表长度计算时间间隔
    let timeSeries = [];

    for (let i = 0; i < list.length; i++) {
      // 计算每个时间点，从中午12点开始
      const minutes = Math.round(interval * i) + 720; // 在这里加720使起点为12:00
      const wrappedMinutes = minutes % totalMinutes; // 确保时间不会超过一天的分钟数
      const hours = Math.floor(wrappedMinutes / 60);
      const mins = wrappedMinutes % 60;

      // 格式化时间为 HH:mm 格式
      const formattedTime = `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`;
      timeSeries.push(formattedTime);
    }
    console.log(timeSeries)
    return timeSeries;
  }

  function updateLightAngle(angle_num) {
    let minutesToAdd = angle_num;
    let newTime = new Date(baseTime.getTime());
    newTime.setMinutes( minutesToAdd*10);

    let cesiumTime = Cesium.JulianDate.fromDate(newTime);
    viewer.clock.currentTime = cesiumTime;
  }
  async function draw_diagram(intersects,cartesian3,mode){
    // console.log('finish')
    // console.log('光线反射值:', reflectance);
    let light_list=[]
    let reflectance=0
    const step = 2; // 或根据需要调整
    let currentValue=0

    // let intersect_judge=
    // updateLightAngle(currentValue)
    await calculate_normal(intersects, cartesian3, mode)
    // console.log(reflectance,'reflectance')
    // return reflectance
    // slider.value = currentValue; // 更新滑块的值
    // console.log(`Current slider value: ${currentValue}`); // 在控制台输出当前值


  }

  // Fly the camera to San Francisco at the given longitude, latitude, and height.
  viewer.camera.flyTo({
    destination: Cesium.Cartesian3.fromDegrees(11.572176066553844, 48.13941501948902, 900),

    orientation: {
      heading: Cesium.Math.toRadians(0.0),
      pitch: Cesium.Math.toRadians(-15.0),
    }
  });

</script>
</div>
</body>
</html>